︠428d1cc2-df9e-4a2f-a791-155ba77564bbs︠
#ElGamel Elliptic curves
def keygen(p,g):
    ''' Generate public and private keys (A, k) given an odd prime p
    and a primitive root g.
    '''
    k = randint(2,p-2)#private key
    A = pow(g,k,p)#public key
    return (A,k)

def findpg(bits):
    '''Return (p, q) where p has at least the specified number of bits,
    and is prime with probability at least 1-pFail, and g of order p-1.
    This can take some time.
    '''
    tries = 0
    while True:
        q = q0 = 1 + 2*randint(1<<(bits-2), 1<<(bits-1)) # odd
        while not is_prime(q):
              q = q + 2
        p = 2*q + 1
        if is_prime(p):
              break
        tries += (q-q0)/2
    # found p - now look for g of maximal order p-1 = 2q
    while True:
        g = randint(2, p-3)
        if g*g % p != 1 and pow(g,q,p) != 1: # order of g is 2, q, or p-1
            break
    return (p,g)
︡1b5ed826-7e9a-44d1-9e3b-bc5cde3ee155︡{"done":true}︡
︠681088cc-dab3-4271-933e-9d6996cba3aes︠
#little Alice
bits = 10
(p,g)=findpg(bits)#generate p and g so alice can create her public key
(a,k)=keygen(p,g)#calculate small Alice public key
print "small ALice p=", p, "g=", g, "\n(private key) k =", k,"\n(public key) a= ",a
︡34253d6c-7bfd-4f1a-a1e7-cb6ad48652f4︡{"stdout":"small ALice p= 1439 g= 306 \n(private key) k = 1086 \n(public key) a=  80\n"}︡{"done":true}︡
︠138a9941-1eae-4808-a5a6-d69bc13fa250s︠
#Big Alice
#A prime p is known, and an elliptic curve E : y^2 = x^3 + bx + c modulo p
#Let G(taking the role of g above) be a point on E that generates the curve, that is, the points
# G, 2G, 3G...(N − 1)G, N p G = O E , where the last point is the point at infinity, and G thus generates all all F p points
#(the total number of points is N p ).

bits =5 #define random number size/range
(Ap,notused)=findpg(bits)#generate a random prime, you can probably find a simpler way
print "big Alice p = ", Ap#Big Alice's random prime
b1 = 5 #change these to match the elliptic curve given
c1 = 7 #change these to match the elliptic curve given

print "b= ", b1, "\nc= ", c1
E1 = EllipticCurve(GF(Ap), [b1,c1]);#generate elliptic curve with Ap, b and c
E1#print out curve
G1=E1.random_point()#this is the g we use instead of the one generated by "findpg()"
print "\nrandom point G=", G1

additiveOrder = G1.additive_order ()#the number at which (additiveOrder * G) = infinity
print "\nadditive order =", additiveOrder
for i in [1..additiveOrder+1]:#keep going until it loops back to 1*G
    print i,"*G= ", i*G1

Alice_private_key = 2*randint(1<<(bits-2), 1<<(bits-1)) #can be any number
Alice_public_key = Alice_private_key*G1#get the public key from the private key
print "\nBig Alice's public elements:\nP= ",Ap,"\nG= ", G1, "\nE= ", E1, "\n(public key)\nA=", Alice_public_key
print "\n(private key)\nk =", Alice_private_key

︡fe514618-bb5a-462e-9932-1253a0408a62︡{"stdout":"big Alice p =  47\n"}︡{"stdout":"b=  5 \nc=  7\n"}︡{"stdout":"Elliptic Curve defined by y^2 = x^3 + 5*x + 7 over Finite Field of size 47\n"}︡{"stdout":"\nrandom point G= (7 : 3 : 1)\n"}︡{"stdout":"\nadditive order = 44\n"}︡{"stdout":"1 *G=  (7 : 3 : 1)\n2 *G=  (22 : 40 : 1)\n3 *G=  (8 : 29 : 1)\n4 *G=  (3 : 7 : 1)\n5 *G=  (38 : 28 : 1)\n6 *G=  (34 : 1 : 1)\n7 *G=  (14 : 1 : 1)\n8 *G=  (28 : 3 : 1)\n9 *G=  (12 : 44 : 1)\n10 *G=  (5 : 4 : 1)\n11 *G=  (0 : 17 : 1)\n12 *G=  (44 : 24 : 1)\n13 *G=  (46 : 46 : 1)\n14 *G=  (6 : 21 : 1)\n15 *G=  (29 : 17 : 1)\n16 *G=  (25 : 24 : 1)\n17 *G=  (2 : 42 : 1)\n18 *G=  (18 : 17 : 1)\n19 *G=  (31 : 22 : 1)\n20 *G=  (43 : 39 : 1)\n21 *G=  (45 : 6 : 1)\n22 *G=  (16 : 0 : 1)\n23 *G=  (45 : 41 : 1)\n24 *G=  (43 : 8 : 1)\n25 *G=  (31 : 25 : 1)\n26 *G=  (18 : 30 : 1)\n27 *G=  (2 : 5 : 1)\n28 *G=  (25 : 23 : 1)\n29 *G=  (29 : 30 : 1)\n30 *G=  (6 : 26 : 1)\n31 *G=  (46 : 1 : 1)\n32 *G=  (44 : 23 : 1)\n33 *G=  (0 : 30 : 1)\n34 *G=  (5 : 43 : 1)\n35 *G=  (12 : 3 : 1)\n36 *G=  (28 : 44 : 1)\n37 *G=  (14 : 46 : 1)\n38 *G=  (34 : 46 : 1)\n39 *G=  (38 : 19 : 1)\n40 *G=  (3 : 40 : 1)\n41 *G=  (8 : 18 : 1)\n42 *G=  (22 : 7 : 1)\n43 *G=  (7 : 44 : 1)\n44 *G=  (0 : 1 : 0)\n45 *G=  (7 : 3 : 1)\n"}︡{"stdout":"\nBig Alice's public elements:\nP=  47 \nG=  (7 : 3 : 1) \nE=  Elliptic Curve defined by y^2 = x^3 + 5*x + 7 over Finite Field of size 47 \n(public key)\nA= (18 : 17 : 1)\n"}︡{"stdout":"\n(private key)\nk = 18\n"}︡{"done":true}︡
︠af6a7f97-47b0-4445-857a-aebd56d25873︠
#Bigbob sends message to Bigalice, using her public elements, G, P, and Alice_public_key
#Encryption and decryption functions
def encrypt_mv_eg(Kpub ,m1,m2):
    x,y = 0,0
    while( (x==0)or(y==0) ):
        r = floor( Ap*random () )#using alice's public prime 'Ap'
        x = (r*Kpub )[0]
        y = (r*Kpub )[1]
    return r*G1, m1*x, m2*y#notice G1, alice's public G

def decrypt_mv_eg(kpri ,enc):
    x = (kpri*enc [0])[0]
    y = (kpri*enc [0])[1]
    return enc [1]*x^-1, enc [2]*y^-1

#Bigbobs's msg, (dont make it too big)
m1 = 13#plaintext x coordinate
m2 = 7#plaintext y coordinate
print "plaintext msg: \nm1=", m1, "\nm2 =", m2
#the following function "encrypt_mv_eg()" takes 3 parameters, then encrypts them and assigns it to "encrypted_msg" variable
encrypted_msg = encrypt_mv_eg(Alice_public_key,m1,m2)
print "encrypted msg ="
encrypted_msg;

︡e34a1cd2-3b39-469a-977e-b7a14d3d7a17︡{"stdout":"plaintext msg: \nm1= 13 \nm2 = 7\n"}︡{"stdout":"encrypted msg =\n"}︡{"stdout":"((28 : 44 : 1), 8, 20)\n"}︡{"done":true}︡
︠81db80e9-7dad-4a46-ba0f-4199058f8161︠
#Bigalice decrypts BigBobs encrypted_msg
decrypted_msg = decrypt_mv_eg(Alice_private_key,encrypted_msg)#put the encrypted msg into the function here
print "decrypted msg from BigBob =", decrypted_msg

︡cacd8a07-80db-4f78-8889-6096c96b11e2︡{"stdout":"decrypted msg from BigBob = (13, 7)\n"}︡{"done":true}︡
︠ad5251a5-08c4-402f-9e4a-d2e6a897c942︠










